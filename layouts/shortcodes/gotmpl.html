{{ $pg := .Page }}
{{ $src := .Get "src" }}

{{ if not (strings.Contains $src ".") }}
  {{ $src = printf "%s.gotmpl" $src }}
{{ end }}

{{ with $pg.Resources.GetMatch $src }}
  {{ $context := dict "Page" $pg }}

  {{ range $key, $value := $.Params }}
    {{ if ne $key "src" }}

      {{ $isJsonFile := strings.HasSuffix $value ".json" }}

      {{ if $isJsonFile }}
        {{ $jsonResource := $pg.Resources.GetMatch $value }}
        {{ if $jsonResource }}
          {{ $jsonData := $jsonResource | transform.Unmarshal }}

          {{ $cleanKey := $key }}
          {{ if strings.HasSuffix $key ".json" }}
            {{ $cleanKey = strings.TrimSuffix $key ".json" }}
          {{ end }}

          {{ $context = merge $context (dict $cleanKey $jsonData) }}
        {{ else }}
          {{ $context = merge $context (dict $key $value) }}
          {{ warnf "JSON file not found: %s (referenced in %s)" $value $pg.File.Path }}
        {{ end }}
      {{ else }}
        {{ $context = merge $context (dict $key $value) }}
      {{ end }}
    {{ end }}
  {{ end }}

  {{/* Generar nombre único para caché */}}
  {{ $paramsHash := $.Params | jsonify | sha256 }}
  {{ $timestamp := now.Unix }}
  {{ $uniqueName := "" }}

  {{ if hugo.IsProduction }}
    {{/* En producción, solo usar hash para mejor caché */}}
    {{ $uniqueName = printf "%s-%s" .Name $paramsHash }}
  {{ else }}
    {{/* En desarrollo, incluir timestamp para invalidar caché */}}
    {{ $uniqueName = printf "%s-%s-%d" .Name $paramsHash $timestamp }}
  {{ end }}

  {{/* Renderizar template */}}
  {{ $rendered := . | resources.ExecuteAsTemplate $uniqueName $context }}
  {{ $rendered.Content | safeHTML }}

{{ else }}
  {{ errorf "Template file not found: %s (referenced in %s)" $src $pg.File.Path }}
{{ end }}
